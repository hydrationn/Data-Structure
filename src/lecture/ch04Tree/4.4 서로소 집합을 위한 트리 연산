4.4 서로소 집합을 위한 트리 연산

(1) 집합에 관련된 연산
- 합집합(union) 연산
- 주어진 원소에 대해 어느 집합에 속해 있는지를 계산하는 find 연산
(2) 서로소 집합(Disjoint Set): 어느 두 집합도 공통된 원소를 갖지 않는 집합들
(3) 서로소 집합의 union과 find 연산은 Part 9.4의 Kruskal의 최소 신장 트리 알고리즘을 구현하는데 활용
(4) 서로소 집합은 1차원 배열에 저장
 원소를 0, 1, 2, ..., n-1로 놓고, 이를 배열의 인덱스로 활용
(5) 집합에 속한 원소들 사이에 특정한 순서는 없고, 또 중복된 원소도 없음
(6) 각 집합은 루트가 대표하고, 루트의 배열 원소에는 루트 자신이 저장되며, 루트가 아닌 노드의 원소에는 부모를 저장

1. 서로소 집합에 대한 연산
(1) union: 2개의 집합을 하나의 집합으로 만드는 연산
(2) find: 인자로 주어지는 x가 속한 집합의 대표 노드, 즉, 루트를 찾는 연산

2. Union 연산
 [ 핵심 아이디어 ] 먼저 union 연산은 rank에 기반하여 (union-by-rank) rank가 높은 루트가 union 후에도 승자(합쳐진 트리의 루트)가 된다.
            -> 트리의 노드 수에 기반(즉, 노드 수가 많은 트리의 루트가 승자가 되도록)하여 union을 수행해도 rank 기반 union과 동일한 성능을 보인다.
- 루트의 rank는 일단은 트리의 높이와 같다고 생각해도 된다.
- rank가 높은 루트를 승자로 만드는 이유: 합쳐진 트리가 더 커지지 않게
- 두 트리의 높이가 같은 경우에는 둘 중 하나의 루트가 승자가 되고 합쳐진 트리의 높이는 1 증가
- rank-기반 union의 목적: 두 트리가 하나로 합쳐진 후에 트리의 높이가 커지는 것을 방지
- find 연산을 수행할 때 루트까지 올라가야 하므로 트리의 높이가 낮을수록 find의 수행 시간을 줄일 수 있기 때문
- 단, 두 트리의 루트들의 rank가 같으면 어쩔 수 없이 하나의 루트가 승자가 되고 승자의 rank도 1 증가
- 각 노드의 rank를 트리의 노드의 수로 근사해서 사용할 수 있다.

3. find 연산
 [ 핵심 아이디어 ] find 연산을 수행하면서 루트까지 올라가는 경로 상의 각 노드의 부모를 루트로 갱신한다. 경로 압축(Path Compression)
- 경로 압축은 당장 find() 연산의 수행 시간을 줄이지 않으나, 추후의 find() 연산의 시간을 단축
- 경로 압축으로 안해 루트의 rank는 트리의 높이와 달라질 수 있다.
 경로 압축으로 인해 루트나 그 밖의 노드들의 rank 값은 변하지 않는다.

4. 수행 시간
(1) union 연산: 두 루트를 각각 찾는 find 연산을 수행한 후 rank를 비교하여 승자가 합쳐진 트리의 루트로 남음
(2) rank가 같은 경우엔 둘 중에 하나가 승가자 되고 승자의 rank를 1 증가시킴. 그러므로 find 연산을 제외한 순수 union 연산의 수행 시간은 O(1) 시간.
(3) find 연산의 수행 시간: 최대 트리의 높이만큼 올라가야 하므로 트리의 높이에 비례
(4) find 연산을 수행하며 경로 압축을 하므로, 경로 상의 노드에 대해 추후에 수행되는 find 연산의 수행 시간은 트리의 높이보다는 적게 소요

