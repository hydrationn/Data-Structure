5.5 B-Tree
- 다수의 키를 가진 노드로 구성되어 다방향 탐색()이 가능한 균형 트리
- 2-3 트리는 B-트리의 일종으로 노드에 키가 2개까지 있을 수 있는 트리
- B-트리는 대용량의 데이터를 위해 고안되어 주로 데이터베이스에 사용

 [ 핵심 아이디어 ] 노드에 수백에서 수천 개의 키를 저장하여 트리의 높이를 낮추자.
     차수가 M인 B-트리는 다방향 탐색 트리로서
    - 모든 이파리는 같은 동일한 깊이를 갖는다.
    - 각 노드(루트 제외)의 자식 수는 ⌈M/2⌉ 이상 M 이하이다.
    - 루트의 자식 수는 2 이상이다.

1. 여러가지 연산
(1) 탐색 연산
- B-트리에서의 탐색은 루트로부터 시작
- 방문한 각 노드에서는 탐색하는 키와 노드의 키들을 비교하여, 적절한 서브트리를 탐색
- 단, B-트리의 노드는 일반적으로 수백 개가 넘는 키를 가지므로 각 노드에서는 이진 탐색 수행

(2) 삽입 연산
- B-트리에서의 삽입은 탐색과 동일한 과정을 거쳐 새로운 키가 저장되어야 할 이파리를 찾는다.
- 이파리에 새 키를 수용할 공간이 있다면, 노드의 키들이 정렬 상태를 유지하도록 새 키를 삽입
- 이파리가 M-1개의 키를 가지고 있으면, M-1개의 키와 새 키 중에서 중간값이 되는 키(중간키)를 부모로 올려보내고, 남은 M-1개의 키를 1/2씩 나누어 각각 별도의 노드에 저장: 분리(Split) 연산

(3) 삭제 연산
- B-트리에서의 삭제는 항상 이파리에서 이루어진다.
- 삭제할 키가 내부 노드에 있으면, 중위 선행자나 중위 후속자를 삭제할 키와 교환한 후에 이파리에서 삭제 수행
- 삭제는 이동(Transfer) 연산과 통합(Fusion) 연산 사용
- 이동 연산: 이파리에서 키가 삭제된 후에 키의 수가 ⌈M/2⌉-1보다 작으면, 자식 수가 ⌈M/2⌉보다 작게 되어 B-트리 조건을 위반. 이때
노드의 좌우의 형제 중에서 도움을 줄 수 있는 노드부터 1개의 키를 부모를 통해 이동

(4) 통합 연산
 키가 삭제된 후 underflow가 발생한 노드 x에 대해 이동 연산이 불가능한 경우, 노드 x와 그의 형제를 1개읜 노드로 통합하고,
노드 x와 형제의 분기점 역할을 하던 부모의 키를 통합된 노드로 끌어내리는 연산

2. B-트리의 확장
 [ B*-트리는 B-트리로서 루트를 제외한 다른 노드의 자식 수가 2/3M~M이어야 한다. ]
    - 즉 각 노드에 적어도 2/3 이상이 키들로 채워져 있어야

=> B-트리에 비해 B*-트리는 공간을 효율적으로 활용
(1) B+-트리는 실세계에서 가장 널리 활용되는 B-트리
 [ B+-트리는 키만을 가지로 B-트리를 구성, 이파리에 키와 관련(실제) 정보를 저장 ]
(2) 키로 구성된 B-트리는 탐색, 삽입, 삭제 연산을 위한 관련된 이파리를 빠르게 찾을 수 있도록 안내해주는 역할만 수행
(3) B+-트리는 전체 레코드를 순차적으로 접근할 수 있도록 이파리들은 연결 리스트로 구현

3. 성능 분석
(1) B-트리에서 삽입이나 삭제 연산의 수행 시간은 각각 B-트리의 높이에 비례. 차수가 M이고 키의 개수가 n인 B-트리의 최대 높이는 O(logM/2 n)이다.
(2) B-트리는 키들의 비교 횟수보다 디스크와 메인 메모리 사이의 블록 이동(Transfer) 수를 최소화해야 한다.
(3) B-트리의 최고 성능을 위해선 1개의 노드가 1개의 디스크 페이지에 맞도록 차수 M을 정한다.
    - 실제로 B-트리들은 M개의 크기를 수백에서 수천으로 사용

