5.1 Binary Search Tree

1. 이진 탐색 트리(Binary Search Tree)
 이진 탐색의 개념을 트리 형태의 구조에 접목한 자료구조
(1) 이진 탐색(Binary Search)
 정렬된 데이터의 중간에 위치한 항목을 기준으로 데이터를 두 부분으로 나누어 가며 특정 항목을 찾는 탐색 방법
(2) 이진 탐색 트리는 이진 트리로서 각 노드가 다음과 같은 이진 탐색 트리 조건을 만족한다.
 각 노드 n의 키는 n의 왼쪽 서브트리에 있는 키보다 크고, n의 오른쪽 서브트리에 있는 키보다 작다.
-> 이진 탐색 트리에서 중위 순회(Inorder Traversal)하면 정렬된다.

2. 이진 탐색 트리 클래스
- 노드() 클래스는 이진 트리의 구현에 사용된 노드와 유사
- 노드 객체: id(키), name(키에 관련된 정보), 왼쪽 자식과 오른쪽 자식을 각각 가리키기 위한 left와 right 필드

(1) 탐색 연산
- 탐색하는 Key가 k라면, 루트의 id와 k를 비교
- k가 id보다 작으면 루트의 왼쪽 서브트리에서 k를 찾고,
  k가 id보다 크면 루트의 오른쪽 서브트리에서 k를 찾으며,
  id가 k와 같으면 탐색에 성공(노드의 Value, 즉, name을 반환)
- 왼쪽이나 오른쪽 서브트리에서 k를 탐색하는 연산은 루트에서의 탐색 연산과 동일

(2) 삽입 연산
- 삽입은 탐색 연산과 유사
- 이미 id가 트리에 있으면 name만 갱신
- id가 트리에 없으면 탐색 연산의 마지막에 null을 반환하는 대신, 삽입하는 값을 가진 새 노드를 생성하고 새 노드를 부모와 연결

(3) 최솟값 찾기
- 최솟값은 루트로부터 왼쪽 자식을 따라 내려가며, null을 만났을 때 null의 부모가 가진 id
- min() 메소드는 delete() 메소드에서 사용
- 최솟값을 가진 노드의 레퍼런스를 리턴

(4) 최솟값 삭제 연산
- 최솟값을 가진 노드 x를 찾아낸 뒤, x의 부모 p와 x의 오른쪽 자식 c를 연결

(5) 삭제 연산
① 삭제할 노드를 찾은 후 이진 탐색 트리 조건을 만족하도록 삭제된 노드의 부모와 자식을 연결해 주어야 함
② 삭제되는 노드가 자식이 없는 경우(case 0), 자식이 하나인 경우(case 1), 자식이 둘인 경우(case 2)로 나누어 delete 연산을 수행
- case 0: 삭제될 노드 x의 부모가 x를 가리키던 레퍼런스를 null로 만든다.
- case 1: x가 한쪽 자식인 c만 가지고 있으면, x의 부모와 x의 자식 c를 직접 연결
- case 2: x의 자리에 중위 순회하면서 x를 방문하기 직전 노드(Inorder Predecessor, 중위 선행자) 또는 직후에 방문되는 노드(Inorder Successor, 중위 후속자)를 이동

3. 수행 시간
- 이진 탐색 트리에서 탐색, 삽입, 삭제 연산은 루트에서 탐색을 시작하여 최악의 경우에 이파리까지 내려가고, 삽입과 삭제 연산은 다시 루트까지 거슬러 올라간다.
- 트리를 1층 내려갈 때는 순환호출이 발생하고, 1층을 올라갈 때는 setLeft() 또는 setRight() 메소드 수행, O(1) 시간
- 각 연산의 수행 시간은 트리의 높이(h)에 비례, O(h)
- n개의 노드가 있는 이진 탐색 트리의 높이가 가장 낮은 경우는 완전 이진 트리 형태일 때이고, 가장 높은 경우는 편향 이진 트리
- 이진 트리의 높이 h:
    ⌈log(n+1)⌉ ≈ log n ≤ h ≤ n
- Empty 이진 탐색 트리에 랜덤 키 n개를 삽이하면 트리의 높이는 약 1.39 log n

