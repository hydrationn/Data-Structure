8. Sort

1. 비교 정렬(comparison sort)
- 배열의 원소 쌍 간의 비교에 기반을 두고 잇다.
- 비교 정렬은 O(n log n)이라는 시간 한계를 넘지 못한다.


2. 선택 정렬(Selection Sort)
(1) 배열에서 아직 정렬되지 않은 부분에서 최솟값을 '선택'하여 정렬된 부분의 바로 오른쪽 원소와 교환하는 정렬 알고리즘

(2) 수행 시간
- 루프가 1번 수행될 때마다 정렬 안 된 부분에서 min 선택
 1번째: n개의 원소 중에서 min을 찾기 위해 n-1번 비교
 2번째: n-1개의 원소 중에서 min을 찾는 데 n-2번 비교
        ...
 마지막 번째: 2개의 원소 1번 비교
- 총 비교 횟수: (n-1)+(n-2)+(n-3)+...+2+1 = n(n+1)/2 = O(n^2)
- 입력에 민감하지 않음(Input Insensitive) -> 항상 O(n^2) 수행 시간 소요


3. 삽입 정렬(Insertion Sort)
(1) 배열이 정렬된 부분과 정렬 안 된 부분으로 나뉘며, 정렬 안 된 부분의 가장 왼쪽 원소를 정렬된 부분에 '삽입'하여 정렬

(2) 현재 원소 삽입 후
    - 정렬된 부분의 원소 수가 1 증가
    - 정렬 안 된 부분의 원소 수는 1 감소

(3) 수행 시간
- 입력에 민감(Input sensitive)
- 입력이 이미 정렬된 경우(최선 경우): n-1번 비교하면 정렬을 마친다. = O(n)
- 입력이 역으로 정렬된 경우(최악 경우): (n-1)+(n-2)+(n-3)+...+2+1 = n(n+1)/2 ≈ 1/2 n^2 = O(n^2)
- 최악 경우 데이터 교환 수: O(n^2)
- 입력 데이터의 순서가 랜덤인 경우(평균 경우)
    현재 원소가 정렬된 앞 부분에 최종적으로 삽입되는 곳이 평균적으로 정렬된 부분의 중간이므로 1/2 * n(n+1)/2 ≈ 1/4 n^2 = O(n^2)

(4) 응용
- 이미 정렬된 파일의 뒷부분에 소량의 신규 데이터를 추가하여 정렬하는 경우(입력이 거의 정렬된 경우) 우수한 성능을 보임.
- 입력 크기가 작은 경우에도 매우 좋은 성능을 보임. 삽입 정렬은 순환 호출을 하지 않으며, 프로그램도 매우 간단하기 때문
- 삽입 정렬은 합병 정렬이나 퀵 정렬과 함께 사용되어 실질적으로 성능 향상
    단, 이론적인 수행 시간은 향상되지 않음


4. 힙 정렬(Heap Sort)
(1) 힙 자료구조를 이용하는 정렬
① 먼저 배열에 저장된 데이터의 키를 우선순위로 하는 최대 힙(Max Heap)을 구성
② 루트의 숫자를 힙의 가장 마지막 노드에 있는 숫자와 교환한 후, 힙 크기 1 감소
③ 루트로 이동한 숫자로 인해 위배된 힙 속성을 downheap 연산으로 복원
④ 이 과정들을 반복하여 정렬

(2) 수행 시간
- 먼저 상향식(Bottom-up)으로 힙 구성: O(n) 시간
- 루트와 힙의 마지막 노드를 교환한 후 downheap() 수행: O(log n) 시간
- 루트와 힙의 마지막 노드를 교환하는 횟수: n-1번

-> 총 수행시간: O(n) + (n-1)*O(log n) = O(n log n)
-> 힙 정렬은 어떠한 입력에도 항상 O(n log n) 시간 소요


5. 합병 정렬(Merge Sort)
(1) 크기가 n인 입력을 n/2 크기로 분할하고, 각각에 대해 순환으로 합병 정렬을 수행한 후, 2개의 각각 정렬된 부분을 합병하는 정렬 알고리즘
- 합병(Merge): 2개의 각각 정렬된 리스트를 1개의 정렬된 리스트로 만드는 것
- 분할 정복(Divide-and-Conquer) 알고리즘: 입력을 분할하여 분할된 입력 각각에 대한 문제를 순환으로 해결한 후 취합하여 문제를 해결하는 알고리즘


6. 퀵 정렬(Quick Sort)
(1) 입력의 맨 왼쪽 원소(피벗, Pivot)를 기준으로 피벗보다 작은 원소들과 큰 원소들을 각각 피벗의 좌우로 분할한 후, 좌우 부분을 각각 순환으로 정렬

(2) 수행 시간
- 최선 경우: 피벗이 매번 입력을 1/2씩 분할하는 경우
- 평균 경우: O(n log n)
- 최악 경우: 피벗이 매번 가장 작거나 가장 큰 경우로 피벗보다 작은 부분이나 큰 부분이 없을 때 -> O(n^2)
- 퀵 정렬은 평균적으로 빠른 수행 시간을 가지며, 보조 메모리를 사용하지 않음.
- 최악 경우 수행 시간이 O(n^2)이므로, 성능 향상 방법들 사용

(3) 성능 향상 방법
① 퀵 정렬은 순환 호출을 사용하므로 입력이 작은 크기가 되었을 때 삽입 정렬을 호출하여 성능 향상
② 피벗의 값에 따라 분할되는 두 영역의 크기가 결정되므로 한 쪽이 너무 커지는 것을 방지하기 위해
-> Median-of-Three 방법: 가장 왼쪽(low), 중간(mid), 가장 오른쪽(high) 원소 중에서 중간값을 피벗으로 사용
    9개의 원소를 선택하여 이들을 3개씩 하나의 그룹으로 여기어, 각 그룹에서 중간값을 선택하고, 선택된 3개의 중간값 중에 중간값을 피벗으로 사용(Median-of-Medians)
③ 안정한 정렬(Stable Sort) 알고리즘은 중복된 키에 대해 입력에서 앞서 있던 키가 정렬 후에도 앞서 있음.
    Stable Sort 예: 삽입 정렬, 합병 정렬

