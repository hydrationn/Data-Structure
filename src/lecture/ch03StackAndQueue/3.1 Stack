3.1 Stack
: 한쪽 끝에서만 항목 삽입/삭제하는 자료구조
-> 후입선출(LIFO, Last In First Out)

- 새 항목을 저장하는 연산: push
- top 항목을 삭제하는 연산: pop

1. 스택의 응용
(1) 컴퍼일러의 괄호 짝 맞추기
 [핵심 아이디어] 왼쪽 괄호는 스택에 push, 오른쪽 괄호를 읽으면 pop 수행
- pop된 왼쪽 괄호와 바로 읽은 오른쪽 괄호가 다른 종류이면 error 처리, 같은 종류이면 다른 괄호를 읽는다.
- 모든 괄호를 읽은 뒤 에러가 없고 스택이 empty이면 정상
- 모든 괄호를 처리한 후, 스택이 empty가 아니면 짝이 맞지 않는 괄호가 스택에 남은 것이므로 에러 처리

(2) 회문(Palindrome) 검사하기
 [핵심 아이디어] 전반부의 문자들을 스택에 push 한 후, 후반부의 각 문자를 차례로 pop한 문자와 비교
- 입력의 1/2인 앞부분을 읽어 스택에 push 한 후,
    문자열의 길이가 짝수이면 뒷부분의 문자 1개를 읽어서 pop한 문자와 비교하는 과정 반복
    문자열의 길이가 홀수이면 중간 문자는 버리고 뒷부분의 문자 1개를 읽어서 pop한 문자와 비교하는 과정 반복
- 마지막 비교까지 두 문자가 동일하고 스택이 empty이면, 입력은 회문
- 입력 길이가 홀수인 경우 중간 문자는 읽고 버린다.

(3) 후위 표기(Postfix Notation) 수식 계산하기
 [핵심 아이디어] 피연산자는 스택에 push하고, 연산자는 2회 pop하여 계산한 후 push
 입력을 좌에서 우로 문자를 1개씩 읽고 이를 C라고 하면
- C가 피연산자이면 C를 push
- C가 연산자(op)이면 pop을 2회 수행한다. 먼저 pop된 피연산자가 B이고, 나중에 pop된 연산자가 A라면, (A or B)를 수행하여 그 결과값을 push

(4) 중위 표기(Infix Notation) 수식의 후위 표기 변환
 [핵심 아이디어] 왼쪽 괄호나 연산자는 스택에 push하고, 피연산자는 출력
 입력을 좌에서 우로 문자를 1개씩 읽는다. 읽은 문자가
    - 피연산자이면, 읽은 문자를 출력
    - 왼쪽 괄호이면, push
    - 오른쪽 괄호이면, 왼쪽 괄호가 나올 때까지 pop하여 출력. 단, 오른쪽이나 왼쪽 괄호는 출력하지 않음.
    - 연산자이면, 자신의 우선순위보다 낮은 연산자가 스택을 top에 나타날 때까지 pop하여 출력하고 읽은 연산자를 push
 입력을 모두 읽었으면 스택이 empty 될 때까지 pop 출력

2. 수식의 표기법
(1) 프로그램을 작성할 때 수식에서 +, -, *, /와 같은 이항 연산자는 2개의 피연산자 사이에 위치: 중위 표기(Infix Notation)
    ex) A+B-C
- 전위 표기(Prefix Notation): 연산자를 피연산자들 앞에 두는 표기
    ex) -+ABC
- 후위 표기(Postfix Notation): 연산자를 피연산자들 뒤에 두는 표기
    ex) AB+C-

(2) 컴파일러는 중위 표기 수식을 후위 표기(Postfix Notation)으로 바꾼다.
 그 이유는 후위 표기법 수식은 괄호 없이 중위 표기 수식을 표현할 수 있기 때문

3. 스택의 기타 응용
- 미로 찾기
- 트리의 순회
- 그래프의 깊이 우선 탐색
- 프로그래밍에서 매우 중요한 함수(메소드) 호출 및 순환 호출도 스택 자료구조를 바탕으로 구현

4. 수행 시간
- 배열 스택의 push와 pop 연산: O(1) 시간
- 배열의 크기를 확대/축소시키는 경우에 스택의 모든 item들을 새 배열로 복사해야 하므로 O(n) 시간
- 단순 연결 리스트 스택의 push와 pop 연산 O(1) 시간

5. java.util.Stack class
(1) java.util 패키지에는 Stack 클래스가 구현되어 있음
 java.util.Vector 클래스를 확장

(2) java.util.Stack Class 일부 멤버에 대한 개요
    public boolean empty()
    public E peek()
    public E pop()
    public void push(E e)
    public int size()

(3) import java.util.Stack;
    Stack<Element> stack = new Stack<>();

(4) 현재는 이 대신 Deque(Double ended queue)를 사용할 것을 권장

