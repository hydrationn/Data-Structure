1. Data Structure
: 일련의 동일한 타입의 데이터를 정돈하여 저장한 구성체
- 배열, 리스트, 스택, 큐, 트리, 해시테이블, 그래프 등
(1) 데이터를 정돈하는 목적: 프로그램에서 저장하는 데이터에 대해 탐색, 삽입, 삭제 등의 연산을 효울적으로 수행하기 위해서
(2) 자료구조를 설계할 때에는 데이터와 데이터에 관련된 연산들을 함께 고려해야 한다.

1. 배열(Array)
: 동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 있는 기초적인 자료구조
    데이터타입[] 배열이름 = new 데이터타입[배열크기];
- 각 항목이 하나의 원소에 저장

2. 추상데이터타입(Abstract Data Type)
 데이터와 그 데이터에 대한 추상적인 연산들로써 구성
    추상데이터타입(ADT), 자바 Interface -구현-> 자료구조, 자바 Class
- '추상'의 의미: 연산을 구체적으로 어떻게 구현하여야 한다는 세부 명세를 포함하고 있지 않다는 의미
- 자료구조는 추상데이터타입을 구체적(실제 프로그램)으로 표현한 것

* 데이터 타입과 연산에 대한 일반적인 명세
    -> 연산이 무엇인지를 명세; 그러나, 그 연산들이 실행되는 방법에 대한 세부사항은 제공되지 않는다.

* 데이터 추상화
    - 객체 지향 프로그래밍 방법론의 기반
    - 데이터와 연산을 독립적으로 구현될 수 있는 별도의 모듈로 캡슐화
        -> 대형 프로젝트 개발을 용이하게 만들어 준다.

3. 수행 시간 분석
(1) 자료구조의 효율성은 자료구조에 대해 수행되는 연산의 수행 시간으로 측정
(2) 자료구조에 대한 연산 수행 시간은 알고리즘의 효율성을 계산하는 방식과 동일
(3) 알고리즘의 성능
- 시간 복잡도(Time Complexity): 수행 시간
- 공간 복잡도(Space Complexity): 알고리즘이 수행되는 동안 사용되는 메모리의 크기
(4) 대부분의 경우 시간 복잡도만 사용
 주어진 문제를 해결하기 위한 대부분의 알고리즘이 비슷한 크기의 메로리 공간을 사용
(5) 알고리즘을 구현한 프로그램을 컴퓨터에서 실행시켜 소요된 시간으로 측정할 수도 있다.
(6) 실제 측정한 시간의 한계점
    - 프로그래머의 숙련도
    - 구현에 사용되 프로그래밍 언어의 종류
    - 알고리즘을 실행한 컴퓨터의 성능
 에 따라 수행 시간은 달라질 수 있다.

4. 시간 복잡도
: 알고리즘(연산)이 실행되는 동안 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타낸다.

 기본 연산(Elementary Operation)
- 테이터간 크기 비교
- 테이터 읽기
- 데이터 갱신
- 단순한 계산 등과 같은 단순한 연산

5. 4종류의 분석
(1) 최악경우 분석(Worst-case Analysis)
: '어떤 입력이 주어지더라도 알고리즘의 수행시간이 얼마 이상은 넘지 않는다'라는 상한(Upper Bound)의 의미

(2) 평균경우 분석(Average-case Analysis)
: 입력의 확률 분포를 가정하여 분석하는데, 일반적으로 균등분포(Uniform Distribution)를 가정

(3) 최선경우 분석(Best-case Analysis)
: 가장 빠른 수행시간을 분석
- 최적(Optimal) 알고리즘을 찾는데 활용

(4) 상각 분석(Amortized Analysis)
: 일련의 연산을 수행하여 총 연산 횟수를 합하고 이를 연산 횟수로 나누어 수행시간을 분석
- amortize는 '분할 상환하다'라는 뜻을 가지고 있다. 그리고 상각은 '보상하여 갚아주다'라는 뜻
- 일련의 연산, 즉 N회의 연산을 수행한 총 시간을 N으로 나누어 1회 연산의 평균 수행시간을 계산
- 입력의 확률분포에 대한 가정이 필요 없으며, 최악 경우 분석보다 매우 정확한 분석이 가능하다.
- 단, 상각 분석이 가능한 알고리즘들은 시간이 아주 오래 걸리는 연산과 짧은 시간이 걸리는 연산들이 뒤섞여서 수행되는 공통점을 가진다.

=> 일반적으로 알고리즘의 수행시간은 최악경우 분석으로 표현

6. 수행시간의 점근표기법
- 수행 시간은 알고리즘이 수행하는 기본 연산 횟수를 입력 크기에 대한 함수로 표현
- 이러한 함수는 다항식으로 표현되며 이를 입력의 크기에 대한 함수로 표현하기 위해 점근표기법(Asymptotic Notation)이 사용
(1) O(Big-Oh)-표기법
(2) Ω(Big-Omega)-표기법
(3) θ(Big-Theta)-표기법

7. 순차 탐색(선형 탐색 또는 직렬 탐색)
- 주어진 목표 값을 찾아 리스트를 앞에서부터 순차적으로 탐색
- 목표가 발견된 첫 번째 위치를 리턴; 목표가 발견되지 않으면 음수를 리턴
- 복잡도는 θ(n), 선형시간(linear time)에 수행

Input: a sequence {a0, a1, a2, ..., an-1} and a target x.
Output: an index value i.
Postcondition: either ai = x, or i < 0
    1. Repeat step2 for i = 0 to n-1.
    2.  If ai = x, return i.
    3. Return -n.

8. O(Big-Oh)-표기법
 [ O-표기의 정의 ] 모든 N >= N0에 대해서 f(N) <= cg(N)이 성립하는 양의 상수 c와 N0가 존재하면, f(N) = O(g(N))이다.
- O-표기의 의미: N0과 같거나 큰 모든 N(즉, N0 이후의 모든 N)에 대해서 f(N)이 cg(N)보다 크지 않다는 것
- f(N) = O(g(N))은 N0보다 큰 모든 N에 대해서 f(N)이 양의 상수를 곱한 g(N)에 미치지 못한다는 뜻
- g(N)을 f(N)의 상한(Upper Bound)이라고 한다.

-> 다항식에서 최고 차수 항만을 취한 뒤, 그 항의 계수를 제거하여 g(N)을 정한다.

9. Ω(Big-Omega)-표기법
 [ Ω-표기의 정의 ] 모든 N >= N0에 대해서 f(N) >= cg(N)이 성립하는 양의 상수 c와 N0가 존재하면, f(N) = Ω(g(N))이다.
- Ω-표기의 의미: N0보다 큰 모든 N에 대해서 f(N)이 cg(N)보다 작지 않다는 것
- f(N) = Ω(g(N))은 양의 상수를 곱한 g(N)이 f(N)에 미치지 못한다는 뜻
- g(N)을 f(N)의 하한(Lower Bound)이라고 한다.

-> g(N)은 정의를 만족하는 가장 높은 차수의 함수를 선택할 것

10. θ(Big-Theta)-표기법
 [ θ-표기의 정의 ] 모든 N >= N0에 대해서 f(N) <= cg(N)이 성립하는 양의 상수 c와 N0가 존재하면, f(N) = O(g(N))이다.
- θ-표기는 수행시간의 O-표기와 Ω-표기가 동일한 경우에 사용한다.
- 2N^2 + 3N + 5 = O(N^2)과 동시에 2N^2 + 3N + 5 = Ω(N^2)이므로, 2N^2 + 3N + 5 = θ(N^2)이다.

11. 자주 사용되는 함수의 O-표기와 이름
 알고리즘의 수행시간은 주로 O-표기를 사용하며, 보다 정확히 표현하기 위해 θ-표기를 사용하기도 한다.
- O(1): 상수시간(Constant Time)
- O(logN): 로그(대수) 시간(Logarithmic Time)
- O(N): 선형시간(Linear Time)
- O(NlogN): 로그선형시간(Log-linear Time)
- O(N^2): 제곱시간(Quadratic Time)
- O(N^3): 세제곱시간(Cubic Time)
- O(2^N): 지수 시간(Exponential Time)

12. 순환(Recursion)
: 메소드의 실행 과정 중 스스로를 호출하는 것
-> 팩토리얼, 조합을 계산하기 위한 식의 표현, 무한한 길이의 숫자 스트림을 만들기, 분기하여 자라나는 트리 자료구조, 프랙털(Fractal) 등의 기본 개념으로 사용
(1) 메소드가 자기 자신을 호출할 때 무한 호출을 방지해야 한다. 스스로의 호출을 중단시킬 수 있는 조건문이 없으면 StackOverflowError가 발생한다.
(2) 순환으로 구현된 메소드는 두 부분으로 구성
- 기본(Base) case: 스스로를 더 이상 호출하지 않는 부분
- 순환 case: 스스로를 호출하는 부분
(3) 일반적으로 순환은 프로그램()의 가독성을 높일 수 있다는 장점을 갖지만 시스템 스택을 사용하기 때문에 메모리 사용 측면에서 비효율적이다.
(4) 반복문으로 변환하기 어려운 순환도 존재하며, 억지로 반복문으로 변환하는 경우 프로그래머가 시스템 스택의 수행을 처리해야 하므로 프로그램이 매우 복잡해질 수 밖에 없다.
(5) 반복문으로 변환된 프로그램의 수행 속도가 순환으로 구현된 프로그램보다 항상 빠르다는 보장은 없다.

