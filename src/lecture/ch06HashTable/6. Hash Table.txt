6. Hash Table
- 이진 탐색 트리의 성능을 개선한 AVL의 삽입과 삭제 연산의 수행 시간은 각각 O(log n)
- O(log n)보다 좋은 성능을 갖는 자료구조는 없을까?

 [ 핵심 아이디어 ] O(log n)보다 빠른 연산을 위해, 키와 1차원 배열의 인덱스 관계를 이용하여 키(항목)을 저장한다.
 - 키를 배열의 인덱스로 그대로 사용하면 메모리 낭비
 - [문제 해결] 키를 변환하여 배열의 인덱스로 사용

1. 해싱(Hashing): 키를 간단한 함수를 사용해 변환한 값을 배열의 인덱스로 이용하여 항목을 저장
(1) 해시 함수(Hash Function): 해싱에 사용되는 함수
(2) 해시값(Hash value): 해시 함수가 계산한 값(해시 주소)
(3) 해시 테이블(Hash Table): 항목이 해시값에 따라 저장되는 배열
(4) 아무리 우수한 해시 함수라도 2개 이상의 항목을 해시 테이블의 같은 원소(장소)에 저장해야 하는 경우 발생
   -> 충돌(Collision): 서로 다른 키들이 동일한 해시값을 가질 때

2. 해시 함수
(1) 가장 이상적인 해시 함수는 키들을 균등하게(uniformly) 해시 테이블의 인덱스로 변환하는 함수
(2) 일반적으로 키는 부여된 의미나 특성을 가진다.
 키의 앞 부분 또는 뒤의 몇 자리 등을 취하여 해시값으로 사용하면 많은 충돌 발생
(3) '균등하게' - 키들을 해시 테이블에 랜덤하게 흩어지도록 저장

* 키를 균등하게 해시 테이블의 인덱스로 변환하기 위해 의미가 부여되어 있는 키를 간단한 계산을 통해 '뒤죽박죽' 만든 후 해시 테이블의 크기에 맞도록 해시값을 계산

3. 대표적인 해시 함수
(1) 중간 제곱(Mid-square) 함수: 키를 제곱한 후, 적절한 크기의 중간 부분 사용
(2) 접기(Folding) 함수: 몇 자리씩 일정하게 끊어서 만든 숫자들의 합을 이용
    예) 123456789012에 대해서 1234 + 5678 + 9012 = 15924를 계산한 후에 해시 테이블의 크기가 1000이라면 15924에서 3자리 수만 해시값으로 사용
(3) 해시 함수들의 공통점
- 키의 모든 자리의 숫자가 함수 계산에 참여
- 계산 결과에서 해시 테이블의 크기에 따라 특정 부분만을 해시값으로 활용
(4) 가장 널리 사용되는 해시 함수: 나눗셈(Division) 함수
- 나눗셈 함수는 키를 소수(Prime) M으로 나눈 뒤, 그 나머지를 해시값으로
- h(key) = key % M
- M을 소수를 사용하는 이유: 나눗셈 연산을 했을 때, 소수가 키들을 균등하게 인덱스로 변환

4. 자바의 hashCode()
(1) 자바의 모든 클래스는 singed 32비트 int를 반환하는 hashCode()를 포함
(2) 자바를 이용하여 해시 테이블을 구현할 때에 일반적으로 hashCode()를 override하여 해시 함수를 구현
(3) 6장에서는 hash() 메소드를 다음과 같이 선언하여 사용

private int hash(Key k) {
    return (k.hashCode() & 0x7fffffff) % M;
}

(4) Integer 객체: hashCode()는 아무런 계산 없이 key를 그대로 반환
(5) Boolean 객체: hashCode()는 key가 true이면 1231, false이면 1237을 각각 반환
(6) Double 객체: hashCode()는 key를 IEEE 64-bit 포맷으로 변환한 후, 모든 bit를 계산에 참여시키기 위해 최상위 32 bit와 최하위 32 bit를 XOR한 결과를 반환
(7) String 객체: key의 문자(char)를 31진수의 숫자로 간주하여 해시값 계산
    예) key = "ball"
       hash = 98*31^3 + 97*31^2 + 108*31^1 + 108*31^0
            = 108 + 31*(108 + 31*(97 + 31*(98))
            = 3016191 반환

5. 개방 주소 방식(Open Addressing)
 해시 테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라 찾아낸 empty 원소에 저장

- 선형 조사(Linear Probing)
- 이차 조사(Quadratic Probing)
- 이중 해싱(Double Hashing)

6. 선형 조사(Linear Probing)
 [ 충돌이 일어난 원소로부터 순차적으로 검색하여 처음 발견한 empty 원소에 충돌된 키 저장 ]
- h(key) = i, 해시 테이블 a[i], a[i+1], a[i+2], ..., a[i+j]를 차례로 검색하여 첫 empty 원소에 key 저장
- 해시 테이블은 1차원 배열이므로, i+j == M이면 a[0]을 검색
    (h(key) + j) % M, j = 0, 1, 2, 3, ...
- 선형 조사는 순차 탐색으로 empty 원소를 찾아 충돌된 키를 저장하므로 해시 테이블의 키들이 빈틈없이 뭉쳐지는 현상 발생: 1차 군집화(Primary Clustering)
- 군집화는 탐색, 삽입, 삭제 연산 시 군집된 키들을 순차적으로 방문해야 하는 문제점을 일으킨다.
- 군집화는 해시 테이블에 empty 원소가 적을수록 더 심화되며 성능을 극단적으로 저하

7. 이차 조사(Quadratic Probing)
 선형 조사와 근본적으로 동일한 충돌 해결 방법
 [ 충돌 후 배열 a에서 (h(key) + j^2) % M, j = 0, 1, 2, 3, ...
- 선형 조사보다 j가 증가할수록 더울 멀리 떨어진 곳의 empty 원소 조사
- 이차 조사는 1차 군집화 문제를 해결
- 같은 해시값을 갖는 서로 다른 키들인 동의어(Synonym)가 같은 점프 시퀀스(Jump Sequence)에 따라 empty 원소를 같은 점프 시퀀스(Jump Sequence)에 따라 empty 원소를 찾아 저장하므로
또 다른 형태의 군집화인 2차 군집화(Secondary Clustering) 발생
- 점프 크기가 j^2만큼씩 커지므로 배열에 empty 원소가 있어도 저장에 실패하는 경우 발생

8. 이중 해싱(Double Hashing)
 [ 2개의 해시 함수 사용, h(key)로 키를 해시 테이블의 인덱스로 변환. d(key)는 충돌 발생 시 다음 위치를 위한 점프 크기를 정함. ]
 [   (h(key) + j*d(key)) mod M, j = 0, 1, 2, ...                                                     ]
- 동의어들이 저마다 제2의 해시 함수를 갖기 때문에 점프 시퀀스가 일정하지 않음.
- 모든 종류의 군집화 문제 해결
- 제2의 함수 d(key)는 점프 크기를 정하는 함수이므로 0을 반환하면 안됨.

9. 폐쇄 주소 방식(Closed Addressing): 해시값에 대응되는 곳에만 키 저장
- 충돌이 발생한 키들은 한 위치에 저장
- 가장 대표적인 방법: 체이닝(Chaining)

10. 재해시와 동적 해싱
 어떤 해싱 방법도 해시 테이블에 비어있는 부분이 거의 없으면 해시 성능이 급격히 저하된다.
 [ 재해시(Rehash): 해시 테이블을 확장시키고 새로운 해시 함수를 사용하여 모든 키를 새 해시 테이블에 다시 저장 ]
- 오프라인(Off-line)에서 수행
- 모든 키를 다시 저장해야 하므로 O(n) 시간 소요
- 재해시 수행 여부는 적재율(Load Factor)에 따라 결정
    적재율 α = (키의 수 n) / (테이블 크기 M)
- 일반적으로 α > 0.75가 되면 해시 테이블 크기를 2배로 확장, α < 0.25가 되면 해시 테이블을 1/2로 축소

11. 동적 해싱(Dynamic Hashing)
 [ 대용량의 데이터베이스를 위한 해시 방법으로 (재해싱을 수행하지 않고) 동적으로 해시 테이블의 크기를 조절 ]

(1) 확장 해싱(Extendible Hashing)
 [ 디렉터리(Directory)를 메인 메모리에 저장하고, 데이터는 디스크 블록 크기의 버킷(Bucket) 단위로 저장 ]
- 버킷: 키를 저장하는 곳

-> 버킷에 overflow가 발생하면 새 버키을 만들어 나누어 저장하며 이때 이 버킷들을 가리키던 디렉터리는 2배로 확장

(2) 선형 해싱(Linear Hashing)
 [ 디렉터리 없이 삽입할 때 버킷을 순서대로 추가 ]
① 버킷은 삽입되는 키가 저장되는 버킷과 무관하게 순차적으로 추가
② 삽입되는 버킷에 저장 공간이 없으면 overflow 체인에 새 키를 임시로 삽입
③ 체인은 나중에 버킷이 추가되면 overflow 체인의 키들을 버킷으로 이동

* ht: 버킷의 배열
      배열 ht는 가능하나 한 매우 크다고 가정한다.
* 활성화된 버킷에 대한 정보를 위한 두 변수 q와 r(0 <= q < 2^r)
 - r: 해시 테이블을 인덱스하기 위해 사용되는 h(k)의 비트 수
 - q: 다음에 분할할 버킷
* 언제든지 0부터 2^r + q - 1까지의 버킷만 활성화
* 오버플로우는 버킷 2^r + q을 활성화시켜 해결한다. 체인 q에 있던 원소들을 버킷 2^r + q을 사용하여 재조정하고, q를 1만큼 증가시킨다.
* q가 2^r이 되면 r을 1만큼 증가시키고 q를 0으로 재설정

12. 해시 방법의 성능 비교
- 해시 방법의 성능은 탐색이나 삽입 연산을 수행할 때 성공과 실패한 경우를 각각 분석하여 측정
- 선형 조사: 적재율 α가 너무 작으면 해시 테이블에 empty 원소가 너무 많고, α 값이 1.0에 근접할수록 군집화가 심화
- 개방 주소 방식의 해싱: α ≈ 0.5. 즉, M ≈ 2n일 때 좋은 성능
- 체이닝: 테이블 크기 M이 항목의 수 N보다 너무 크면 대부분의 연결 리스트들이 empty가 되고, M이 N보다 너무 작으면 연결 리스트들의 길이가 너무 길어져 해시 성능 매우 저하
- 일반적으로 M이 소수이고, α ≈ 10 정도일 때 좋은 성능

+ java.util.Map 인터페이스
public interface Map {
    public void clear();
    public boolean containsKey(Object key);
    public boolean containsValue(Object value);
    public Set entrySet();
    public boolean equals(Object object);
    public Object get(Object key);
    public int hashCode();
    public boolean isEmpty();
    public Set keySet();
    public Object put(Object key, Object value);
    ...
}
 java.util.HashMap이 java.util.Map 인터페이스 구현

-> 디폴트 최대 적재율이 0.75인 폐쇄주소법 사용
